<!DOCTYPE html>
<html lang="fr">

<head>
	<meta charset="utf-8">
	<META NAME="robots" CONTENT="noindex">
	<title>Brume — Menu Editor</title>
	<meta name="viewport" content="width=device-width, initial-scale=1.0">
	<link
		href="https://fonts.googleapis.com/css2?family=Yeseva+One&family=Courier+Prime:wght@400;700&family=Bebas+Neue&display=swap"
		rel="stylesheet">
	<style>
		:root {
			--bg: #161008;
			--bg2: #1e1508;
			--border: #3d2e12;
			--gold: #d0972d;
			--muted: #6a5030;
			--text: #ffeacf;
			--red: #a03020;
			--c0: #d0972d;
			--c1: #9b72c8;
			--c2: #4a9fd4;
			--c3: #4caf7d;
			--c4: #d47a30;
			--c5: #c84a6a;
			--cc: #555040;
			--cat: #8a7060;
		}

		*,
		*::before,
		*::after {
			box-sizing: border-box;
			margin: 0;
			padding: 0
		}

		html {
			font-size: 15px
		}

		body {
			font-family: 'Courier Prime', monospace;
			background: var(--bg);
			color: var(--text);
			min-height: 100vh;
			overflow-x: hidden;
			-webkit-text-size-adjust: 100%
		}

		/* ── TOP BAR ── */
		#topbar {
			position: sticky;
			top: 0;
			z-index: 100;
			background: var(--bg2);
			border-bottom: 1px solid var(--border);
			padding: .5em .8em;
			display: flex;
			align-items: center;
			gap: .45em;
			flex-wrap: wrap
		}

		.logo {
			font-family: 'Yeseva One', serif;
			color: var(--gold);
			font-size: 1.1em;
			margin-right: auto;
			white-space: nowrap
		}

		.logo sub {
			font-family: 'Bebas Neue', sans-serif;
			font-size: .5em;
			color: var(--muted);
			letter-spacing: .12em;
			vertical-align: middle;
			margin-left: .35em
		}

		.btn {
			font-family: 'Courier Prime', monospace;
			font-size: .68em;
			font-weight: 700;
			text-transform: uppercase;
			letter-spacing: .06em;
			padding: .38em .85em;
			border-radius: 999px;
			border: 1.5px solid var(--border);
			background: transparent;
			color: var(--muted);
			cursor: pointer;
			transition: all .14s;
			white-space: nowrap;
			min-height: 2em
		}

		.btn:hover,
		.btn:active {
			border-color: var(--gold);
			color: var(--gold)
		}

		.btn.primary {
			border-color: var(--gold);
			background: var(--gold);
			color: var(--bg)
		}

		.btn.primary:hover,
		.btn.primary:active {
			background: #e0a838
		}

		.btn.on {
			border-color: var(--gold);
			color: var(--gold)
		}

		#topbar input {
			font-family: 'Courier Prime', monospace;
			padding: .38em .85em;
			border-radius: 999px;
			border: 1.5px solid var(--border);
			background: var(--bg);
			color: var(--text);
			width: 10em;
			outline: none;
			font-size: max(.72em, 16px)
		}

		#topbar input:focus {
			border-color: var(--gold)
		}

		#status {
			width: 100%;
			font-size: .7em;
			color: var(--muted);
			padding-left: .2em;
			min-height: 1em
		}

		#status.ok {
			color: #4caf7d
		}

		#status.err {
			color: var(--red)
		}

		/* ── LEGEND ── */
		#legend {
			display: flex;
			gap: .45em;
			flex-wrap: wrap;
			align-items: center;
			padding: .35em .8em;
			background: var(--bg2);
			border-bottom: 1px solid var(--border);
			font-size: .60em;
			font-weight: 700;
			text-transform: uppercase;
			letter-spacing: .06em
		}

		.leg {
			padding: .18em .55em;
			border-radius: 999px;
			border: 1.5px solid;
			white-space: nowrap
		}

		#legend-hint {
			margin-left: auto;
			color: var(--muted);
			font-weight: 400;
			text-transform: none;
			letter-spacing: 0;
			font-size: 1em;
			white-space: nowrap
		}

		/* ── PANELS ── */
		.panel {
			display: none
		}

		.panel.active {
			display: block
		}

		#editor-wrap {
			padding: .4em 0 6em
		}

		/* ── LINE ROW ── */
		.line {
			display: flex;
			align-items: flex-start;
			border-radius: 3px;
			min-height: 1.4em;
			position: relative;
			transition: background .1s
		}

		.line:not(.editing) {
			cursor: default
		}

		.line:not(.editing):hover {
			background: rgba(255, 255, 255, .025)
		}

		.line.editing {
			background: rgba(208, 151, 45, .05);
			outline: 1px solid rgba(208, 151, 45, .3);
			outline-offset: -1px;
			border-radius: 3px;
			cursor: default
		}

		.line.drag-ghost-over {
			outline: 2px solid var(--gold);
			outline-offset: -1px;
			border-radius: 3px
		}

		.line.dragging {
			opacity: .2
		}

		.handle {
			flex-shrink: 0;
			width: 1.6em;
			align-self: stretch;
			display: flex;
			align-items: flex-start;
			justify-content: center;
			padding-top: .4em;
			color: transparent;
			font-size: .75em;
			user-select: none;
			transition: color .12s;
			cursor: grab;
			touch-action: none
		}

		.line:hover .handle {
			color: var(--muted)
		}

		.line-accent {
			flex-shrink: 0;
			width: 3px;
			align-self: stretch;
			border-radius: 2px;
			margin-right: .55em;
			opacity: .75
		}

		.line-content-col {
			flex: 1;
			min-width: 0;
			display: flex;
			flex-direction: column
		}

		/* ── PREVIEW (read-only, always shown) ── */
		.line-preview {
			display: flex;
			align-items: flex-start;
			min-height: 1.4em;
			overflow: hidden;
			position: relative;
			cursor: pointer
		}

		.line-colored-preview {
			padding: .22em .3em .22em 0;
			pointer-events: none;
			user-select: none;
			white-space: pre;
			overflow: hidden;
			flex: 1;
			min-width: 0
		}

		/* Expanded: wrap full content */
		.line.expanded .line-colored-preview {
			white-space: pre-wrap;
			word-break: break-word;
			overflow: visible
		}

		.line.expanded .line-preview {
			overflow: visible
		}

		.line-fade {
			position: absolute;
			right: 0;
			top: 0;
			bottom: 0;
			width: 3em;
			pointer-events: none;
			background: linear-gradient(to right, transparent, var(--bg) 90%);
			transition: opacity .15s
		}

		.line.expanded .line-fade {
			opacity: 0;
			pointer-events: none
		}

		.line.editing .line-fade {
			background: linear-gradient(to right, transparent, #19110a 90%)
		}

		/* ── INLINE EDIT ROW ── */
		.line-edit-row {
			display: none;
			flex-direction: column;
			gap: 0;
			padding: .3em .3em .4em 0;
			border-top: 1px solid rgba(208, 151, 45, .2);
			margin-top: .15em;
			font-size: 14px
		}

		.line.editing .line-edit-row {
			display: flex
		}

		/*
      Single contenteditable div = the edit field.
      It renders the colored spans directly, so the caret is always
      perfectly aligned with the visible text. No overlay tricks needed.
    */
		.line-ce {
			font-family: 'Courier Prime', monospace;
			font-size: 16px;
			line-height: 1.55;
			word-break: break-all;
			white-space: pre-wrap;
			padding: .4em .65em;
			border: 1.5px solid var(--border);
			border-radius: 5px;
			background: rgba(0, 0, 0, .4);
			outline: none;
			width: 100%;
			caret-color: var(--gold);
			min-height: 2em;
			cursor: text;
		}

		.line-ce:focus {
			border-color: var(--gold);
			background: rgba(0, 0, 0, .55)
		}

		/* Segment colors — used both in preview and in the CE editor */
		.s0 {
			color: var(--c0);
			font-style: italic
		}

		.s1 {
			color: var(--c1);
			font-style: italic
		}

		.s2 {
			color: var(--c2);
			font-weight: 700
		}

		.s3 {
			color: var(--c3)
		}

		.s4 {
			color: var(--c4)
		}

		.s5 {
			color: var(--c5)
		}

		.sc {
			color: var(--cc);
			font-style: italic
		}

		.su {
			color: var(--border)
		}

		/* underscore separators */
		.sa {
			color: var(--cat);
			font-style: italic
		}

		/* @... parts */
		.serr {
			color: var(--red);
			font-weight: 700
		}

		/* over-level error */

		.line-edit-actions {
			display: flex;
			gap: .5em;
			align-items: center;
			padding-top: .3em;
			font-size: 14px
		}

		.line-edit-hint {
			font-size: 11px;
			color: var(--muted);
			flex: 1;
			white-space: nowrap
		}

		.line-type-label {
			flex-shrink: 0;
			font-size: 11px;
			font-weight: 700;
			text-transform: uppercase;
			letter-spacing: .07em;
			padding: 0 .2em 0 .4em;
			align-self: flex-start;
			padding-top: .35em;
			white-space: nowrap
		}



		/* ── EDIT BUTTON (always visible, next to label) ── */
		.line-edit-btn {
			flex-shrink: 0;
			background: none;
			border: 1px solid transparent;
			border-radius: 6px;
			color: var(--muted);
			font-size: 15px;
			cursor: pointer;
			padding: .3em .55em;
			align-self: flex-start;
			margin-top: .1em;
			transition: all .12s;
			line-height: 1;
			min-width: 2.4em;
			min-height: 2.4em;
			display: flex;
			align-items: center;
			justify-content: center
		}

		.line-edit-btn:hover,
		.line-edit-btn:active {
			border-color: var(--gold);
			color: var(--gold)
		}

		.line.editing .line-edit-btn {
			color: var(--gold);
			border-color: rgba(208, 151, 45, .4)
		}

		.line-del {
			flex-shrink: 0;
			background: none;
			border: 1px solid transparent;
			border-radius: 6px;
			color: var(--border);
			font-size: 15px;
			cursor: pointer;
			padding: .3em .5em;
			transition: all .12s;
			align-self: flex-start;
			margin-top: .1em;
			min-width: 2.4em;
			min-height: 2.4em;
			display: flex;
			align-items: center;
			justify-content: center
		}

		.line:hover .line-del {
			color: var(--muted) !important
		}

		.line-del:hover,
		.line-del:active {
			color: var(--red) !important
		}

		#add-bar {
			display: flex;
			gap: .5em;
			flex-wrap: wrap;
			justify-content: center;
			margin-top: 1.5em;
			padding: 0 1em
		}

		/* ── RAW PANEL ── */
		#raw-wrap {
			height: calc(100vh - 95px)
		}

		#raw-textarea {
			width: 100%;
			height: 100%;
			background: var(--bg);
			color: var(--text);
			font-family: 'Courier Prime', monospace;
			font-size: .88em;
			border: none;
			outline: none;
			padding: 1em;
			resize: none;
			line-height: 1.65;
			tab-size: 2
		}

		/* ── DIFF PANEL ── */
		#diff-wrap {
			padding: 1em 1em 4em;
			font-family: 'Courier Prime', monospace;
			font-size: .82em;
			line-height: 1.65
		}

		.diff-line {
			display: block;
			padding: .05em .4em;
			border-radius: 2px;
			white-space: pre-wrap;
			word-break: break-all
		}

		.diff-add {
			background: rgba(76, 175, 125, .13);
			color: #4caf7d
		}

		.diff-del {
			background: rgba(160, 48, 32, .13);
			color: #d06050;
			text-decoration: line-through
		}

		.diff-same {
			color: var(--muted)
		}

		::-webkit-scrollbar {
			width: 5px
		}

		::-webkit-scrollbar-track {
			background: var(--bg)
		}

		::-webkit-scrollbar-thumb {
			background: var(--border);
			border-radius: 3px
		}
	</style>
</head>

<body>

	<div id="topbar">
		<div class="logo">Brume <sub>editor</sub></div>
		<button class="btn on" id="btn-visual" onclick="switchPanel('visual')">✦ Visuel</button>
		<button class="btn" id="btn-raw" onclick="switchPanel('raw')">⌨ Brut</button>
		<button class="btn" id="btn-diff" onclick="switchPanel('diff')">⟳ Diff</button>
		<button class="btn" onclick="copyMenu()">⧉ Copier</button>
		<button class="btn" onclick="window.open('menu.html','_blank')">↗ Menu</button>
		<input type="email" id="emailBox" placeholder="email" autocomplete="on">
		<input type="password" id="passwordBox" placeholder="mot de passe" autocomplete="on">
		<button class="btn primary" onclick="pushToSupabase()">↑ Push</button>
		<div id="status"></div>
	</div>

	<div id="legend">
		<span class="leg" style="border-color:var(--c0);color:var(--c0)">bloc</span>
		<span class="leg" style="border-color:var(--c1);color:var(--c1)">_ catégorie</span>
		<span class="leg" style="border-color:var(--c2);color:var(--c2)">__ produit</span>
		<span class="leg" style="border-color:var(--c3);color:var(--c3)">_ prix</span>
		<span class="leg" style="border-color:var(--c4);color:var(--c4)">_ description</span>
		<span class="leg" style="border-color:var(--c5);color:var(--c5)">_____ commentaire</span>
		<span class="leg" style="border-color:var(--cc);color:var(--cc)"># commenté</span>
		<span id="legend-hint">✎ = modifier · ⠿ = déplacer</span>
	</div>

	<div id="panel-visual" class="panel active">
		<div id="editor-wrap">
			<div id="lines-container"></div>
			<div id="add-bar">
				<button class="btn" onclick="insertLine(null,'')">＋ Vide</button>
				<button class="btn" onclick="insertLine(null,'Nouveau Bloc')">＋ Bloc</button>
				<button class="btn" onclick="insertLine(null,'_')">＋ Catégorie</button>
				<button class="btn" onclick="insertLine(null,'__')">＋ Produit</button>
				<button class="btn" onclick="insertLine(null,'_____')">＋ Commentaire</button>
			</div>
		</div>
	</div>

	<div id="panel-raw" class="panel">
		<div id="raw-wrap"><textarea id="raw-textarea" spellcheck="false"></textarea></div>
	</div>

	<div id="panel-diff" class="panel">
		<div id="diff-wrap"></div>
	</div>

	<script src="https://unpkg.com/@supabase/supabase-js@2"></script>
	<script>
		const SupabaseUrl = "https://cpvxjedlgjhcdqjyecmf.supabase.co";
		const SupabaseKey = "eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJpc3MiOiJzdXBhYmFzZSIsInJlZiI6ImNwdnhqZWRsZ2poY2RxanllY21mIiwicm9sZSI6ImFub24iLCJpYXQiOjE2OTkyNjMzMzYsImV4cCI6MjAxNDgzOTMzNn0.Rs-bqvUb0Eq7NEKX3tFc8WHJOjzk1Rc4fgRRU6OtVNs";
		let _sb;
		try { _sb = supabase.createClient(SupabaseUrl, SupabaseKey); } catch (e) { }

		let rawLines = [], savedText = '';

		const SIZES = ['0.95em', '0.85em', '0.80em', '0.75em', '0.75em', '0.72em'];
		const LABELS = ['bloc', 'catégorie', 'produit', 'prix', 'description', 'commentaire'];
		const COLORS = ['var(--c0)', 'var(--c1)', 'var(--c2)', 'var(--c3)', 'var(--c4)', 'var(--c5)'];

		// ─────────────────────────────────────────────────────────────
		// COLORIZER
		// Rules (simplified — _ is ONLY a level/separator char, never in text):
		//   • leading _s  → level indicator (dimmed)
		//   • remaining _s → field separators (dimmed)
		//   • @...         → annotation (italic muted)
		//   • text between separators gets color of its segment index
		//   • line starting with # → full comment color
		// ─────────────────────────────────────────────────────────────
		function esc(s) { return s.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;'); }

		function colorize(raw) {
			if (!raw || raw.trim() === '') return '';
			if (raw.trim().startsWith('#')) return `<span class="sc">${esc(raw)}</span>`;

			// Count ALL leading underscores — no cap, so we can detect overflow
			let lvl = 0;
			while (raw[lvl] === '_') lvl++;

			const leadingU = raw.slice(0, lvl);
			const body = raw.slice(lvl);
			const segs = body.split('_');

			let html = '';
			// Leading underscores: show overflow ones in red
			if (leadingU) {
				const okU = leadingU.slice(0, 5);   // first 5 underscores are fine
				const errU = leadingU.slice(5);       // beyond 5 → error
				if (okU) html += `<span class="su">${esc(okU)}</span>`;
				if (errU) html += `<span class="serr">${esc(errU)}</span>`;
			}

			segs.forEach((seg, i) => {
				const realLvl = lvl + i;   // un-capped level for this segment
				if (i > 0) {
					// Separator underscore: error color if already over level
					const sepCls = realLvl > 5 ? 'serr' : 'su';
					html += `<span class="${sepCls}">_</span>`;
				}
				const cls = realLvl > 5 ? 'serr' : `s${Math.min(realLvl, 5)}`;
				const atParts = seg.split('@');
				html += `<span class="${cls}">${esc(atParts[0])}</span>`;
				for (let j = 1; j < atParts.length; j++)
					html += `<span class="${realLvl > 5 ? 'serr' : 'sa'}">@${esc(atParts[j])}</span>`;
			});
			return html;
		}

		function lineInfo(raw) {
			if (!raw || raw.trim() === '') return { color: 'transparent', label: '', size: '0.88em' };
			if (raw.trim().startsWith('#')) return { color: 'var(--cc)', label: '#', size: '0.80em' };
			let lvl = 0; while (raw[lvl] === '_') lvl++;
			lvl = Math.min(lvl, 5);
			return { color: COLORS[lvl], label: LABELS[lvl], size: SIZES[lvl] };
		}

		// ─────────────────────────────────────────────────────────────
		// contenteditable helpers
		// We store plain text in rawLines; the CE div shows colored HTML.
		// On input we extract plaintext, recolorize, and restore caret.
		// ─────────────────────────────────────────────────────────────

		function getCaretOffset(el) {
			// Returns character offset of caret within el's plain text
			const sel = window.getSelection();
			if (!sel || sel.rangeCount === 0) return 0;
			const range = sel.getRangeAt(0);
			const pre = range.cloneRange();
			pre.selectNodeContents(el);
			pre.setEnd(range.endContainer, range.endOffset);
			return pre.toString().length;
		}

		function setCaretOffset(el, offset) {
			// Restores caret to character offset within el
			const walker = document.createTreeWalker(el, NodeFilter.SHOW_TEXT);
			let remaining = offset;
			let node;
			while ((node = walker.nextNode())) {
				if (remaining <= node.textContent.length) {
					const range = document.createRange();
					range.setStart(node, remaining);
					range.collapse(true);
					const sel = window.getSelection();
					sel.removeAllRanges();
					sel.addRange(range);
					return;
				}
				remaining -= node.textContent.length;
			}
			// fallback: end of element
			const range = document.createRange();
			range.selectNodeContents(el);
			range.collapse(false);
			window.getSelection().removeAllRanges();
			window.getSelection().addRange(range);
		}

		function getCEText(el) {
			// Extract plain text from CE div (strip HTML, get innerText equivalent)
			return el.innerText.replace(/\n/g, '');
		}

		function setCEContent(el, raw) {
			el.innerHTML = colorize(raw);
		}

		// ─────────────────────────────────────────────────────────────
		// RENDER
		// ─────────────────────────────────────────────────────────────
		function renderAll() {
			const container = document.getElementById('lines-container');
			container.innerHTML = '';
			rawLines.forEach((text, i) => container.appendChild(buildLineEl(text, i)));
		}

		function buildLineEl(text, idx) {
			const { color, label, size } = lineInfo(text);

			const line = document.createElement('div');
			line.className = 'line';
			line.dataset.idx = idx;

			// Drag handle
			const handle = document.createElement('span');
			handle.className = 'handle';
			handle.textContent = '⠿';
			line.appendChild(handle);

			// Accent bar
			const accent = document.createElement('div');
			accent.className = 'line-accent';
			accent.style.background = color;
			line.appendChild(accent);

			// Content column
			const col = document.createElement('div');
			col.className = 'line-content-col';
			col.style.fontSize = size;

			// ── Preview (always visible, read-only) ──
			const preview = document.createElement('div');
			preview.className = 'line-preview';
			const coloredPreview = document.createElement('div');
			coloredPreview.className = 'line-colored-preview';
			coloredPreview.innerHTML = colorize(text);
			const fade = document.createElement('div');
			fade.className = 'line-fade';
			preview.appendChild(coloredPreview);
			preview.appendChild(fade);
			col.appendChild(preview);

			// ── Inline edit row ──
			const editRow = document.createElement('div');
			editRow.className = 'line-edit-row';

			// The contenteditable field — colored text, caret always correct
			const ce = document.createElement('div');
			ce.className = 'line-ce';
			ce.contentEditable = 'true';
			ce.spellcheck = false;
			ce.setAttribute('autocorrect', 'off');
			ce.setAttribute('autocapitalize', 'off');
			setCEContent(ce, text);

			// Action row
			const actRow = document.createElement('div');
			actRow.className = 'line-edit-actions';
			const hint = document.createElement('span');
			hint.className = 'line-edit-hint';
			hint.textContent = '↵ valider · esc annuler';
			const btnCancel = document.createElement('button');
			btnCancel.className = 'btn';
			btnCancel.textContent = 'Annuler';
			const btnConfirm = document.createElement('button');
			btnConfirm.className = 'btn primary';
			btnConfirm.textContent = '✓ Valider';
			actRow.appendChild(hint);
			actRow.appendChild(btnCancel);
			actRow.appendChild(btnConfirm);

			editRow.appendChild(ce);
			editRow.appendChild(actRow);
			col.appendChild(editRow);
			line.appendChild(col);

			// Type label (always visible)
			const typeLabel = document.createElement('span');
			typeLabel.className = 'line-type-label';
			typeLabel.style.color = color;
			typeLabel.textContent = label;
			line.appendChild(typeLabel);

			// Edit button — the ONLY way to open the editor
			const editBtn = document.createElement('button');
			editBtn.className = 'line-edit-btn';
			editBtn.textContent = '✎';
			editBtn.title = 'Modifier';
			editBtn.addEventListener('click', e => {
				e.stopPropagation();
				if (line.classList.contains('editing')) {
					applyClose(line, true);
				} else {
					openEditHere();
				}
			});
			line.appendChild(editBtn);

			// Delete
			const del = document.createElement('button');
			del.className = 'line-del';
			del.textContent = '✕';
			del.addEventListener('click', e => {
				e.stopPropagation();
				rawLines.splice(idx, 1);
				renderAll();
			});
			line.appendChild(del);

			// ── CE input handler ──
			// On every input: save caret, recolorize, restore caret, sync preview
			ce.addEventListener('input', () => {
				const caret = getCaretOffset(ce);
				const raw = getCEText(ce);
				setCEContent(ce, raw);
				setCaretOffset(ce, caret);
				// Sync preview + accent + label
				coloredPreview.innerHTML = colorize(raw);
				const info = lineInfo(raw);
				accent.style.background = info.color;
				col.style.fontSize = info.size;
				typeLabel.textContent = info.label;
				typeLabel.style.color = info.color;
			});

			// Prevent real newlines from being inserted
			ce.addEventListener('keydown', e => {
				if (e.key === 'Enter' && !e.shiftKey) {
					e.preventDefault();
					applyClose(line, true);
					const val = rawLines[idx];
					let prefix = ''; for (let i = 0; i < val.length; i++) { if (val[i] === '_') prefix += '_'; else break; }
					insertLine(idx, prefix);
					setTimeout(() => openEdit(idx + 1), 30);
				} else if (e.key === 'Escape') {
					e.preventDefault();
					applyClose(line, false);
				} else if (e.key === 'Backspace' && getCEText(ce) === '') {
					e.preventDefault();
					applyClose(line, false);
					rawLines.splice(idx, 1);
					renderAll();
				}
			});

			// Strip formatting on paste — plain text only
			ce.addEventListener('paste', e => {
				e.preventDefault();
				const plain = (e.clipboardData || window.clipboardData).getData('text/plain').replace(/\r?\n/g, '');
				const caret = getCaretOffset(ce);
				const cur = getCEText(ce);
				const next = cur.slice(0, caret) + plain + cur.slice(caret);
				setCEContent(ce, next);
				setCaretOffset(ce, caret + plain.length);
				coloredPreview.innerHTML = colorize(next);
				const info = lineInfo(next);
				accent.style.background = info.color;
				col.style.fontSize = info.size;
				typeLabel.textContent = info.label;
				typeLabel.style.color = info.color;
			});

			// ── Open / close ──
			function openEditHere() {
				document.querySelectorAll('.line.editing').forEach(l => {
					if (l !== line) applyClose(l, true);
				});
				// Also collapse any expanded line
				document.querySelectorAll('.line.expanded').forEach(l => l.classList.remove('expanded'));
				setCEContent(ce, rawLines[idx]);
				coloredPreview.innerHTML = colorize(rawLines[idx]);
				line.classList.add('editing');
				setTimeout(() => {
					ce.focus();
					// Place caret at end
					const range = document.createRange();
					range.selectNodeContents(ce);
					range.collapse(false);
					const sel = window.getSelection();
					sel.removeAllRanges();
					sel.addRange(range);
					line.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
				}, 30);
			}

			btnConfirm.addEventListener('click', e => { e.stopPropagation(); applyClose(line, true); });
			btnCancel.addEventListener('click', e => { e.stopPropagation(); applyClose(line, false); });

			// Tap preview → toggle expanded (shows full wrapped content, no editor)
			let pdY = 0, pdT = 0;
			preview.addEventListener('pointerdown', e => { pdY = e.clientY; pdT = Date.now(); }, { passive: true });
			preview.addEventListener('pointerup', e => {
				if (line.classList.contains('editing')) return;
				if (Math.abs(e.clientY - pdY) < 8 && (Date.now() - pdT) < 500) {
					e.stopPropagation();
					line.classList.toggle('expanded');
				}
			});

			// Clicking anywhere outside: close editor if open, collapse if expanded
			document.addEventListener('pointerdown', e => {
				if (!line.contains(e.target)) {
					if (line.classList.contains('editing')) applyClose(line, true);
					if (line.classList.contains('expanded')) line.classList.remove('expanded');
				}
			}, { capture: true, passive: true });

			setupDrag(handle, line, idx);
			return line;
		}

		// Save & close any line element
		function applyClose(targetLine, doSave) {
			const ce = targetLine.querySelector('.line-ce');
			const tIdx = parseInt(targetLine.dataset.idx);
			if (doSave && ce && !isNaN(tIdx)) {
				const val = getCEText(ce);
				rawLines[tIdx] = val;
				const info = lineInfo(val);
				const html = colorize(val);
				targetLine.querySelector('.line-colored-preview').innerHTML = html;
				setCEContent(ce, val);
				targetLine.querySelector('.line-accent').style.background = info.color;
				targetLine.querySelector('.line-content-col').style.fontSize = info.size;
				const lbl = targetLine.querySelector('.line-type-label');
				lbl.textContent = info.label; lbl.style.color = info.color;
			}
			targetLine.classList.remove('editing');
		}

		// Open edit by index
		function openEdit(idx) {
			const lineEl = document.querySelector(`.line[data-idx="${idx}"]`);
			if (!lineEl) return;
			document.querySelectorAll('.line.editing').forEach(l => {
				if (l !== lineEl) applyClose(l, true);
			});
			const ce = lineEl.querySelector('.line-ce');
			setCEContent(ce, rawLines[idx] || '');
			lineEl.querySelector('.line-colored-preview').innerHTML = colorize(rawLines[idx] || '');
			lineEl.classList.add('editing');
			setTimeout(() => {
				ce.focus();
				const range = document.createRange();
				range.selectNodeContents(ce);
				range.collapse(false);
				const sel = window.getSelection();
				sel.removeAllRanges();
				sel.addRange(range);
				lineEl.scrollIntoView({ behavior: 'smooth', block: 'nearest' });
			}, 30);
		}

		function insertLine(afterIdx, text = '') {
			if (afterIdx === null) rawLines.push(text);
			else rawLines.splice(afterIdx + 1, 0, text);
			renderAll();
			setTimeout(() => openEdit(afterIdx === null ? rawLines.length - 1 : afterIdx + 1), 30);
		}

		// ── DRAG ──────────────────────────────────────────────────────
		let dragState = null;

		function setupDrag(handle, lineEl, idx) {
			handle.addEventListener('mousedown', e => startDrag(e.clientY, lineEl, idx, 'mouse'));
			handle.addEventListener('touchstart', e => startDrag(e.touches[0].clientY, lineEl, idx, 'touch'), { passive: true });
		}

		function startDrag(clientY, lineEl, idx, type) {
			const rect = lineEl.getBoundingClientRect();
			const ghost = lineEl.cloneNode(true);
			ghost.style.cssText = `position:fixed;left:${rect.left}px;top:${rect.top}px;width:${rect.width}px;opacity:.85;z-index:999;background:var(--bg2);border:1px solid var(--gold);border-radius:4px;pointer-events:none;box-shadow:0 4px 24px rgba(0,0,0,.6)`;
			document.body.appendChild(ghost);
			lineEl.classList.add('dragging');
			dragState = { srcIdx: idx, ghost, lineEl, offsetY: clientY - rect.top };
			if (type === 'touch') {
				document.addEventListener('touchmove', onTouchMove, { passive: false });
				document.addEventListener('touchend', onTouchEnd, { once: true });
			}
		}

		function moveDrag(clientY) {
			if (!dragState) return;
			dragState.ghost.style.top = (clientY - dragState.offsetY) + 'px';
			document.querySelectorAll('.line.drag-ghost-over').forEach(l => l.classList.remove('drag-ghost-over'));
			const t = getLineAtY(clientY);
			if (t && t !== dragState.lineEl) t.classList.add('drag-ghost-over');
		}

		function endDrag(clientY) {
			if (!dragState) return;
			const { srcIdx, ghost, lineEl } = dragState;
			ghost.remove(); lineEl.classList.remove('dragging');
			document.querySelectorAll('.line.drag-ghost-over').forEach(l => l.classList.remove('drag-ghost-over'));
			const t = getLineAtY(clientY);
			if (t && t !== lineEl) {
				const destIdx = parseInt(t.dataset.idx);
				if (!isNaN(destIdx) && destIdx !== srcIdx) {
					const before = clientY < t.getBoundingClientRect().top + t.getBoundingClientRect().height / 2;
					const moved = rawLines.splice(srcIdx, 1)[0];
					let dest = srcIdx < destIdx ? destIdx - 1 : destIdx;
					if (!before) dest++;
					rawLines.splice(dest, 0, moved);
					renderAll();
				}
			}
			dragState = null;
		}

		document.addEventListener('mousemove', e => moveDrag(e.clientY));
		document.addEventListener('mouseup', e => endDrag(e.clientY));
		function onTouchMove(e) { e.preventDefault(); moveDrag(e.touches[0].clientY); }
		function onTouchEnd(e) { endDrag(e.changedTouches[0].clientY); document.removeEventListener('touchmove', onTouchMove); }

		function getLineAtY(y) {
			for (const el of document.querySelectorAll('.line')) {
				const r = el.getBoundingClientRect();
				if (y >= r.top && y <= r.bottom) return el;
			}
			return null;
		}

		// ── PANELS ────────────────────────────────────────────────────
		function switchPanel(name) {
			['visual', 'raw', 'diff'].forEach(p => {
				document.getElementById(`panel-${p}`).classList.toggle('active', p === name);
				document.getElementById(`btn-${p}`).classList.toggle('on', p === name);
			});
			if (name === 'raw') document.getElementById('raw-textarea').value = getText();
			if (name === 'diff') renderDiff();
		}

		document.getElementById('raw-textarea').addEventListener('input', () => {
			rawLines = document.getElementById('raw-textarea').value.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
		});

		// ── DIFF ──────────────────────────────────────────────────────
		function renderDiff() {
			const orig = savedText.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
			const wrap = document.getElementById('diff-wrap');
			if (orig.join('\n') === rawLines.join('\n')) {
				wrap.innerHTML = '<span style="color:var(--muted)">Aucune modification.</span>'; return;
			}
			wrap.innerHTML = lcs(orig.slice(0, 400), rawLines.slice(0, 400)).map(d =>
				`<span class="diff-line diff-${d.type}">${d.type === 'add' ? '＋' : d.type === 'del' ? '－' : '　'} ${esc(d.text)}</span>`
			).join('\n');
		}

		function lcs(a, b) {
			const m = a.length, n = b.length;
			const dp = Array.from({ length: m + 1 }, () => new Uint16Array(n + 1));
			for (let i = m - 1; i >= 0; i--) for (let j = n - 1; j >= 0; j--)
				dp[i][j] = a[i] === b[j] ? dp[i + 1][j + 1] + 1 : Math.max(dp[i + 1][j], dp[i][j + 1]);
			const r = []; let i = 0, j = 0;
			while (i < m || j < n) {
				if (i < m && j < n && a[i] === b[j]) { r.push({ type: 'same', text: a[i] }); i++; j++; }
				else if (j < n && (i >= m || dp[i][j + 1] >= dp[i + 1][j])) { r.push({ type: 'add', text: b[j] }); j++; }
				else { r.push({ type: 'del', text: a[i] }); i++; }
			}
			return r;
		}

		// ── SAVE ──────────────────────────────────────────────────────
		function getText() { return rawLines.join('\n'); }

		function copyMenu() {
			navigator.clipboard.writeText(getText()).then(() => setStatus('Copié !', 'ok'));
		}

		async function pushToSupabase() {
			const email = document.getElementById('emailBox').value.trim();
			const pw = document.getElementById('passwordBox').value;
			if (!email || !pw) { setStatus('Email et mot de passe requis.', 'err'); return; }
			setStatus('Connexion…', '');
			try {
				const { error: e1 } = await _sb.auth.signInWithPassword({ email, password: pw });
				if (e1) throw e1;
				const content = getText();
				const { error: e2 } = await _sb.from('menu.menu').insert([{ content }]);
				if (e2) throw e2;
				savedText = content;
				setStatus('✓ Publié !', 'ok');
			} catch (err) { setStatus('Erreur : ' + (err.message || err), 'err'); }
		}

		function setStatus(msg, cls) {
			const el = document.getElementById('status');
			el.textContent = msg; el.className = cls || '';
			if (cls === 'ok') setTimeout(() => { el.textContent = ''; el.className = ''; }, 3500);
		}

		// ── INIT ──────────────────────────────────────────────────────
		async function init() {
			setStatus('Chargement…', '');
			let text = '';
			try {
				if (_sb) {
					const { data, error } = await _sb.from('menu.menu').select('content').limit(1).order('id', { ascending: false });
					if (!error && data?.[0]?.content) { text = data[0].content; setStatus('Chargé depuis Supabase', 'ok'); }
					else throw 0;
				} else throw 0;
			} catch {
				try {
					text = await (await fetch('menu.menu', { cache: 'no-cache' })).text();
					setStatus('Fichier local chargé', 'ok');
				} catch { setStatus('Impossible de charger le menu.', 'err'); }
			}
			savedText = text;
			rawLines = text.replace(/\r\n/g, '\n').replace(/\r/g, '\n').split('\n');
			renderAll();
		}

		init();
	</script>
</body>

</html>